// Generated by CoffeeScript 1.6.3
(function() {
  var GenericSprite, Interaction, Rule, SpriteFactory, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  GenericSprite = (function(_super) {
    __extends(GenericSprite, _super);

    function GenericSprite(spriteId) {
      var sWidth, shapeParams;
      this.spriteId = spriteId;
      sWidth = this.spriteType * 5;
      shapeParams = {
        height: 100,
        width: 100,
        strokeWidth: sWidth,
        fill: "rgb(0,255,0)",
        stroke: "rgb(0,0,0)",
        cornerSize: 20
      };
<<<<<<< HEAD
      fabric.Rect.call(this, shapeParams);
      /*
      programming = false
      tmpX = 0
      tmpY = 0
      */

      /*
          event.stopPropagation()
          event.preventDefault();
            
          if !programming
              console.log "remember this", this.getAbsolutePosition().x, this.getAbsolutePosition().y
              # remember all my current info
              tmpX = this.getAbsolutePosition().x
              tmpY = this.getAbsolutePosition().y
              this.moveTo(rulesLayer)
          else
              newRule = new Rule()
              dx = this.getAbsolutePosition().x - tmpX
              dy = this.getAbsolutePosition().y - tmpY
              myTransform =
                  dx: dx
                  dy: dy
              newRule.setTransform(myTransform)
              this.addRule( newRule )
              console.log "analyze diff", tmpX, this.getAbsolutePosition().x, tmpX - this.getAbsolutePosition().x
              this.setPosition(tmpX, tmpY)
              this.moveTo(layer)
          
          rulesLayer.draw()
          
          programming = !programming
          console.log programming
      
      #this.on 'touchmove', (e) ->
      #    alert e
      */

=======
      Kinetic.Image.call(this, shapeParams);
      programming = false;
      tmpX = 0;
      tmpY = 0;
      this.on('dblclick dbltap', function(event) {
        var myTransform;
        event.stopPropagation();
        event.preventDefault();
        if (!programming) {
          console.log("remember this", _this.getAbsolutePosition().x, _this.getAbsolutePosition().y);
          tmpX = _this.getAbsolutePosition().x;
          tmpY = _this.getAbsolutePosition().y;
          _this.moveTo(rulesLayer);
        } else {
          myTransform = {
            dx: _this.getAbsolutePosition().x - tmpX,
            dy: _this.getAbsolutePosition().y - tmpY
          };
          _this.addRule(new Rule(myTransform));
          console.log("analyze diff", tmpX, _this.getAbsolutePosition().x, tmpX - _this.getAbsolutePosition().x);
          _this.setPosition(tmpX, tmpY);
          _this.moveTo(layer);
        }
        rulesLayer.draw();
        programming = !programming;
        return console.log(programming);
      });
>>>>>>> 3be1a2edb45438d0edc13e15aaf4dae678a573c6
    }

    GenericSprite.prototype.applyRules = function(environment) {
      var rule, _i, _len, _ref, _results;
      _ref = this._rules;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _results.push(rule.act(this, environment));
      }
      return _results;
    };

    GenericSprite.prototype.addRule = function(rule) {
      this._rules.push(rule);
      return this._rules.length - 1;
    };

    GenericSprite.prototype.setRule = function(index, rule) {
      if (this._rules[index] !== void 0) {
        return this._rules[index] = rule;
      } else {
        throw Error("The rule index " + index + " doesn't exist.");
      }
    };

    GenericSprite.prototype.addTransform = function(transform) {
      var myRule;
      myRule = new Rule();
      myRule.setTransform(transform);
      return this.addRule(myRule);
    };

    GenericSprite.prototype.applyTransform = function(transform) {
      console.log("apply transform");
      return this.set({
        left: this.getLeft() + transform.dx,
        top: this.getTop() + transform.dy,
        angle: this.getAngle() + transform.dr,
        width: this.getWidth() + transform.dxScale,
        height: this.getHeight() + transform.dyScale
      });
    };

    GenericSprite.prototype.showLearning = function() {
      console.log("showLearning");
      this.set({
        borderColor: "red",
        cornerColor: "red"
      });
      return canvas.renderAll();
    };

    GenericSprite.prototype.showNormal = function() {
      console.log("showNoraml");
      this.set({
        borderColor: "rgb(210,210,255)",
        cornerColor: "rgb(210,210,255)"
      });
      return canvas.renderAll();
    };

    return GenericSprite;

  })(fabric.Rect);

  SpriteFactory = function(spriteType, imageObj) {
    var Sprite, _ref;
    console.log("sprite factory" + spriteType + imageObj);
    Sprite = (function(_super) {
      __extends(Sprite, _super);

      function Sprite() {
        _ref = Sprite.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      console.log("class sprite");

      Sprite.prototype.spriteType = spriteType;

      Sprite.prototype.imageObj = imageObj;

      Sprite.prototype._rules = [];

      return Sprite;

    })(GenericSprite);
    return Sprite;
  };

  Rule = (function() {
    Rule.prototype.defaultTransform = {
      dx: 0,
      dy: 0,
      dr: 0,
      dxScale: 1,
      dyScale: 1
    };

    function Rule(transform) {
      var p, v, _ref;
      _ref = this.defaultTransform;
      for (p in _ref) {
        v = _ref[p];
        if (!(p in transform)) {
          transform[p] = v;
        }
      }
      this.transform = transform;
    }

    Rule.prototype.act = function(sprite, environment) {
      return sprite.applyTransform(this.transform);
    };

    return Rule;

  })();

  Interaction = (function(_super) {
    __extends(Interaction, _super);

    function Interaction() {
      _ref = Interaction.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Interaction.prototype.setEnvironment = function(requiredEnvironment) {
      this.requiredEnvironment = requiredEnvironment;
    };

    Interaction.prototype.act = function(sprite, environment) {
      var minCount, shouldAct, spriteType, _ref1;
      shouldAct = true;
      _ref1 = this.requiredEnvironment;
      for (spriteType in _ref1) {
        minCount = _ref1[spriteType];
        if (!(spriteType in environment)) {
          shouldAct = false;
        } else if (environment[spriteType] < minCount) {
          shouldAct = false;
        }
      }
      if (shouldAct) {
        return sprite.applyTransform(this.transform);
      }
    };

    return Interaction;

  })(Rule);

  window.spriteList = [];

  window.spriteTypeList = [];

  window.tick = function() {
    var sprite, _i, _len;
    for (_i = 0, _len = spriteList.length; _i < _len; _i++) {
      sprite = spriteList[_i];
      sprite.applyRules();
    }
    return canvas.renderAll();
  };

  /*
      if programming 
          programming = false
          for child in rulesLayer.getChildren()
              child.moveTo(layer)
          rulesLayer.draw()
  */


  window.loadSpriteTypes = function() {
    var spriteTypeList;
    console.log("loading sprite types");
    spriteTypeList = [];
    return $("img").each(function(i, sprite) {
      console.log("loading sprite type" + i);
      window.spriteTypeList.push(SpriteFactory(i, sprite));
      return $(sprite).draggable({
        revert: false,
        helper: "clone",
        stop: function(ev) {
          var newSprite;
          console.log(i);
          newSprite = new window.spriteTypeList[i];
          spriteList.push(newSprite);
          newSprite.setTop(ev.clientY);
          newSprite.setLeft(ev.clientX);
          canvas.add(newSprite);
          return canvas.renderAll();
        }
      });
      /*
      $(sprite).bind 'dragend', (e) ->
          e.preventDefault();
          console.log "sprite ", $(sprite).attr("data-frame-id"),  " added"
          # this should be ok now because they've been pished in the right order? hmm...
          newSprite = new spriteTypeList[i] 
          console.log "dropped dragend", e.originalEvent.clientX , e.originalEvent.clientY
          newSprite.setPosition(e.originalEvent.clientX, e.originalEvent.clientY)
          layer.add( newSprite )
          spriteList.push( newSprite )
          stage.draw()
      
      
      $(sprite).bind 'touchstart', (e) ->
          e.preventDefault();
      
      $(sprite).bind 'touchmove', (e) ->
          e.preventDefault();
      
      $(sprite).bind 'touchend', (e) ->
          console.log "sprite ", $(sprite).attr("data-frame-id"),  " added"
          # this should be ok now because they've been pished in the right order? hmm...
          newSprite = new spriteTypeList[i]
          dropX = e.originalEvent.changedTouches[0].pageX
          dropY = e.originalEvent.changedTouches[0].pageY
          newSprite.setPosition( dropX , dropY )
          layer.add( newSprite )
          spriteList.push( newSprite )
          stage.draw()
          #e.stopPropagation()
          #e.preventDefault();
      
      # I think we don't need these anymore, but just in case
      $(sprite).bind 'dbltap', (e) -> 
          alert "sprite ", $(sprite).attr("data-frame-id"),  " added dbltap"
          # this should be ok now because they've been pished in the right order? hmm...
          newSprite = new spriteTypeList[i] 
          layer.add( newSprite )
          spriteList.push( newSprite )
          layer.draw()
          #e.stopPropagation()
          e.preventDefault();
          
      $(sprite).bind 'dblclick', (e) -> 
          console.log "sprite ", $(sprite).attr("data-frame-id"),  " added dblclick"
          # this should be ok now because they've been pished in the right order? hmm...
          newSprite = new spriteTypeList[i] 
          layer.add( newSprite )
          spriteList.push( newSprite )
          layer.draw()
          #e.stopPropagation()
          e.preventDefault();
      */

    });
  };

  window.init = function() {
    var moveDown, moveRight, spin, stretchy;
    window.Star = SpriteFactory('Star');
    window.starA = new Star('A');
    window.spriteList.push(starA);
    layer.add(starA);
    stage.add(layer);
    moveRight = new Rule({
      dx: 10
    });
    starA.addRule(moveRight);
    moveDown = new Rule({
      dy: 10
    });
    starA.addRule(moveDown);
    spin = new Rule({
      dr: Math.PI / 6
    });
    starA.addRule(spin);
    stretchy = new Rule({
      dyScale: 1.1
    });
    return starA.addRule(stretchy);
  };

}).call(this);
