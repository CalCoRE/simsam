// Generated by CoffeeScript 1.6.3
(function() {
  var _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Rule = (function() {
    function Rule(spriteType) {
      this.spriteType = spriteType;
      this.action = null;
      this.type = '';
      this.typeint = -1;
    }

    Rule.prototype.act = function(sprite, obj, environment) {
      console.log('Rule[' + this.name + '].act: ' + sprite.spriteType);
      if (this.action !== null) {
        return this.action.act(sprite);
      }
    };

    Rule.prototype.prep = function(sprite, environment) {};

    Rule.prototype.setActionType = function(type) {
      var actClass;
      this.type = type;
      actClass = (function() {
        switch (type) {
          case 'transform':
            return TransformAction;
          case 'clone':
            return CloneAction;
          case 'sprout':
            return SproutAction;
          case 'delete':
            return DeleteAction;
        }
      })();
      switch (type) {
        case 'transform':
          this.typeint = 0;
          break;
        case 'clone':
          this.typeint = 1;
          break;
        case 'sprout':
          this.typeint = 2;
          break;
        case 'delete':
          this.typeint = 3;
      }
      return this.action = new actClass();
    };

    Rule.prototype.addTransform = function(start, end) {
      if (this.type !== 'transform') {
        console.log('Error: addTransform called on other type of Rule');
      }
      this.action = new TransformAction();
      return this.action.setTransformDelta(start, end);
    };

    Rule.prototype.addRandom = function(range) {
      this.action.randomRange = range;
      return this.action.stateRandom = true;
    };

    Rule.prototype.addClone = function() {
      this.type = 'clone';
      this.typeint = 1;
      return this.action = new CloneAction();
    };

    Rule.prototype.addSprout = function() {
      this.type = 'sprout';
      this.typeint = 2;
      return this.action = new SproutAction();
    };

    Rule.prototype.addDelete = function() {
      this.type = 'delete';
      this.typeint = 3;
      return this.action = new DeleteAction();
    };

    Rule.prototype.toJSON = function() {
      var object;
      object = {};
      object.type = 'default';
      object.internaltype = this.type;
      object.typeint = this.typeint;
      object.action = this.action.toJSON();
      return object;
    };

    Rule.createFromData = function(data) {
      var act, actClass, actionObj, className, obj;
      className = '';
      className = (function() {
        switch (data.type) {
          case 'overlap':
            return OverlapInteraction;
          case 'interaction':
            return Interaction;
          case 'default':
            return Rule;
        }
      })();
      if (data.type === 'default') {
        obj = new className;
      } else {
        obj = new className(data.targetType);
      }
      obj.type = data.internaltype;
      obj.typeint = data.typeint;
      actionObj = data.action;
      actClass = (function() {
        switch (actionObj.type) {
          case 'transform':
            return TransformAction;
          case 'clone':
            return CloneAction;
          case 'sprout':
            return SproutAction;
          case 'delete':
            return DeleteAction;
        }
      })();
      act = new actClass;
      act.restoreFromJSON(actionObj);
      obj.action = act;
      return obj;
    };

    return Rule;

  })();

  window.Interaction = (function(_super) {
    __extends(Interaction, _super);

    function Interaction(target) {
      Interaction.__super__.constructor.call(this, target);
      if (typeof target === 'object') {
        console.log('Interaction: New ' + target.spriteType);
        this.targetType = target.spriteType;
      } else {
        this.targetType = target;
      }
    }

    Interaction.prototype.setEnvironment = function(requiredEnvironment) {
      this.requiredEnvironment = requiredEnvironment;
    };

    Interaction.prototype.act = function(sprite, iObj, environment) {
      var minCount, shouldAct, spriteType, _ref;
      shouldAct = true;
      _ref = this.requiredEnvironment;
      for (spriteType in _ref) {
        minCount = _ref[spriteType];
        if (!(spriteType in environment)) {
          shouldAct = false;
        } else if (environment[spriteType] < minCount) {
          shouldAct = false;
        }
      }
      if (shouldAct) {
        return sprite.applyTransform(this.transform);
      }
    };

    Interaction.prototype.toJSON = function() {
      var obj;
      obj = Interaction.__super__.toJSON.apply(this, arguments);
      obj.type = 'interaction';
      obj.targetType = this.targetType;
      return obj;
    };

    return Interaction;

  })(Rule);

  window.OverlapInteraction = (function(_super) {
    __extends(OverlapInteraction, _super);

    function OverlapInteraction() {
      _ref = OverlapInteraction.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    OverlapInteraction.prototype.setEnvironment = function(requiredEnvironment) {
      this.requiredEnvironment = requiredEnvironment;
    };

    OverlapInteraction.prototype.prep = function(sprite, environment) {
      return this.actOn(sprite);
    };

    OverlapInteraction.prototype.actOn = function(sprite) {
      var obj, objects, _i, _len;
      objects = canvas.getObjects();
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (obj === sprite) {
          continue;
        }
        if (!(obj instanceof GenericSprite)) {
          continue;
        }
        if (obj.spriteType !== this.targetType) {
          continue;
        }
        if (obj.trueIntersectsWithObject(sprite)) {
          return obj;
        }
      }
      return false;
    };

    OverlapInteraction.prototype.act = function(sprite, iObj, environment) {
      if (iObj === false || iObj === null) {
        return false;
      }
      return this.action.act(sprite);
    };

    OverlapInteraction.prototype.addClone = function() {
      return OverlapInteraction.__super__.addClone.apply(this, arguments);
    };

    OverlapInteraction.prototype.addSprout = function() {
      return OverlapInteraction.__super__.addSprout.apply(this, arguments);
    };

    OverlapInteraction.prototype.toJSON = function() {
      var obj;
      obj = OverlapInteraction.__super__.toJSON.apply(this, arguments);
      obj.type = 'overlap';
      obj.targetType = this.targetType;
      return obj;
    };

    return OverlapInteraction;

  })(Interaction);

  window.applyToRuleArray = function(ruleArray, callback, data) {
    var rc, rule, ruleSet, setKey, spriteTypeKey;
    for (spriteTypeKey in ruleArray) {
      ruleSet = ruleArray[spriteTypeKey];
      for (setKey in ruleSet) {
        rule = ruleSet[setKey];
        rc = callback(rule, spriteTypeKey, data);
        if (rc === false) {
          return;
        }
      }
    }
  };

  window.ruleBuildJSON = function(ruleArray, rulesOutput) {
    var json, rule, ruleSet, setArray, setKey, spriteTypeKey, _results;
    _results = [];
    for (spriteTypeKey in ruleArray) {
      ruleSet = ruleArray[spriteTypeKey];
      setArray = [];
      for (setKey in ruleSet) {
        rule = ruleSet[setKey];
        json = rule.toJSON();
        setArray[rule.typeint] = json;
      }
      _results.push(rulesOutput[spriteTypeKey] = setArray);
    }
    return _results;
  };

}).call(this);

/*
//@ sourceMappingURL=rules.map
*/
